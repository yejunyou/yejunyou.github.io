<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统原理,编译," />










<meta name="description" content="前语： 本篇是《深入理解计算机系统》书中第七章的「链接」，根据自己的理解摘抄整理的学习笔记，一方面概念比较多，容易混淆，整理便于记忆，加深理解。书中还有不少示例代码和练习，这里没有展示出来，但也不妨碍理解链接这个重要的过程。  可重定位目标模块：Relocatable target module，下文简称RTM 可重定位目标文件：Relocatable target file，下文简称RTF  链">
<meta name="keywords" content="操作系统原理,编译">
<meta property="og:type" content="article">
<meta property="og:title" content="链接">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;19&#x2F;%E9%93%BE%E6%8E%A5&#x2F;index.html">
<meta property="og:site_name" content="you1024">
<meta property="og:description" content="前语： 本篇是《深入理解计算机系统》书中第七章的「链接」，根据自己的理解摘抄整理的学习笔记，一方面概念比较多，容易混淆，整理便于记忆，加深理解。书中还有不少示例代码和练习，这里没有展示出来，但也不妨碍理解链接这个重要的过程。  可重定位目标模块：Relocatable target module，下文简称RTM 可重定位目标文件：Relocatable target file，下文简称RTF  链">
<meta property="og:locale" content="en">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;19&#x2F;%E9%93%BE%E6%8E%A5&#x2F;72.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;19&#x2F;%E9%93%BE%E6%8E%A5&#x2F;73.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;19&#x2F;%E9%93%BE%E6%8E%A5&#x2F;78.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;19&#x2F;%E9%93%BE%E6%8E%A5&#x2F;713.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;19&#x2F;%E9%93%BE%E6%8E%A5&#x2F;715.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;19&#x2F;%E9%93%BE%E6%8E%A5&#x2F;716.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;19&#x2F;%E9%93%BE%E6%8E%A5&#x2F;7161.png">
<meta property="og:updated_time" content="2019-12-19T12:08:48.065Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;19&#x2F;%E9%93%BE%E6%8E%A5&#x2F;72.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/12/19/链接/"/>





  <title>链接 | you1024</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">you1024</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">献给所热爱的一切</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/19/%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YoU1024">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="you1024">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">链接</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-19T20:02:07+08:00">
                2019-12-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>前语：</p>
<p>本篇是《深入理解计算机系统》书中第七章的「链接」，根据自己的理解摘抄整理的学习笔记，一方面概念比较多，容易混淆，整理便于记忆，加深理解。书中还有不少示例代码和练习，这里没有展示出来，但也不妨碍理解链接这个重要的过程。</p>
<ul>
<li>可重定位目标模块：<code>Relocatable target module</code>，下文简称<code>RTM</code></li>
<li>可重定位目标文件：<code>Relocatable target file</code>，下文简称<code>RTF</code></li>
</ul>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li>链接<code>linking</code>：将各种代码和片段收集，组合成一个单一文件的过程。这个文件可以被加载（复制）到内存执行</li>
<li>链接的执行时机：<ul>
<li>编译时 (<code>compile time</code>)：源代码翻译成机器码</li>
<li>加载时 (<code>load time</code>)：程序被加载器加载到（copy）内存执行</li>
<li>运行时 (<code>run time</code>)：由应用程序来执行</li>
</ul>
</li>
<li>链接是由连接器<code>linker</code>来执行的<ul>
<li>角色：分离编译 <code>separate compilation</code></li>
<li>作用：只重新编译修改的文件，重新链接他们，未改动的不用编译</li>
</ul>
</li>
<li>理解连接器的好处：<ul>
<li>如何构造大型程序</li>
<li>避免危险的编译错误</li>
<li>理解语言作用域规则是如何实现的</li>
<li>理解其他重要的系统概念</li>
<li>利用共享库</li>
</ul>
</li>
</ul>
<h1 id="1-编译器驱动程序"><a href="#1-编译器驱动程序" class="headerlink" title="1.编译器驱动程序"></a>1.编译器驱动程序</h1><ul>
<li><p>编译器驱动程序在需要的时候，调用：语言预处理器、编译器、汇编器、连接器</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> sum(<span class="built_in">array</span>, <span class="number">2</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; ++i)&#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个静态链接。连接器把<code>RTF</code>组合，最终形成一个可行执行目标文件prog。</p>
<p>操作：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Og -o prog main<span class="selector-class">.c</span> sum<span class="selector-class">.c</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  中间经过各种xx器的处理，输入输出文件如图：</p>
<p>  <img src="/2019/12/19/%E9%93%BE%E6%8E%A5/72.png" alt></p>
<h1 id="2-静态链接"><a href="#2-静态链接" class="headerlink" title="2.静态链接"></a>2.静态链接</h1><ul>
<li>静态连接器输入：<code>RTF</code>和命令行参数</li>
<li>输出：完全链接的、可以加载和运行的、可执行目标文件</li>
<li>输出的组成：<ul>
<li>组成：代码 + 数据节<code>sectoin</code></li>
<li>指令在一节，初始化的全局变量在一节，未初始化的全局变量在另一节</li>
</ul>
</li>
<li>为了构造可执行文件，连接器完成的两个主要任务：<ul>
<li>符号解析：<ul>
<li>目标文件引用了外部符号，它们的定义可能是一个函数、全局变量、静态变量</li>
<li>符号解析就是把引用和定义关联起来</li>
</ul>
</li>
<li>重定位：根据每个符号的定义，与一个内存位置关联起来</li>
</ul>
</li>
<li>一个事实：目标文件就是一些字节块的集合<ul>
<li>这些字节块：</li>
<li>有的包含程序数据</li>
<li>有的包含程序代码</li>
<li>有的包含引导其和加载器的数据结构</li>
</ul>
</li>
</ul>
<h1 id="3-目标文件"><a href="#3-目标文件" class="headerlink" title="3.目标文件"></a>3.目标文件</h1><p>有三种形式：</p>
<ul>
<li><code>RTF</code>：<ul>
<li>包含二进制代码和数据</li>
<li>编译时与其他<code>RTF</code>合并，创建一个可执行目标文件</li>
</ul>
</li>
<li>可执行目标文件：<ul>
<li>包含二进制代码和数据</li>
<li>可以直接<code>copy</code>到内存执行</li>
</ul>
</li>
<li>共享目标文件：<ul>
<li>特殊类型的<code>RTF</code></li>
<li>在加载或者运行时，动态的加载进内存并链接</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>不同系统的目标文件格式：<ul>
<li><code>Unix</code>：<code>a.out</code></li>
<li><code>Window</code>:<code>PE(portable executable)</code></li>
<li><code>Mac-OS X</code>:<code>Mach-O</code></li>
<li><code>X86-64 Linux</code>:<code>ELF (Executable and Linkable Format)</code></li>
</ul>
</li>
</ul>
<h1 id="4-RTF"><a href="#4-RTF" class="headerlink" title="4.RTF"></a>4.<code>RTF</code></h1><p><img src="/2019/12/19/%E9%93%BE%E6%8E%A5/73.png" alt></p>
<ul>
<li><code>ELF</code>头：<ul>
<li>以一个16字节的序列开始</li>
<li>序列描述了生成该文件的系统的字的大小、字节顺序</li>
<li>余下信息:<ul>
<li>帮助连接器语法分析</li>
<li>解释目标文件类型（可重定位、可执行、可共享）</li>
<li>机器类型（如<code>x86-64</code>）</li>
<li>节头部表的文件偏移</li>
<li>节头部表的数量、大小</li>
<li>不同节的位置和大小，都是节头部表描述的</li>
</ul>
</li>
</ul>
</li>
<li>.text: 程序编译后的机器代码</li>
<li>.rodata：只读数据</li>
<li>.date：<ul>
<li>已经初始化的全局C和静态变量</li>
<li>局部C变量在运行时保存在栈</li>
</ul>
</li>
<li>.bss：<ul>
<li>未初始化的全局和静态C变量，以及初始化为0的全局和静态变量</li>
<li>这个节不占用实际空间，它仅仅是一个占位符【提高空间效率】</li>
<li>运行时，内存分配这些变量，初始值为0</li>
<li>Ps：bss是 block storage start的缩写，有人形象说是 better save space【节省空间】</li>
</ul>
</li>
<li>.symtab：<ul>
<li>符号表，存放定义和引用函数的信息</li>
<li>全局变量的信息</li>
<li>注意：它和编译器的符号表不同，它不包含局部变量的条目</li>
</ul>
</li>
<li>.rel.text：<ul>
<li>调用外部函数，引用全局变量</li>
<li>链接器在和其他文件组合的时候，需要修改这些位置</li>
</ul>
</li>
<li>.rel.data：<ul>
<li>所有全局变量的重定位信息</li>
<li>任何已经初始化的全局变量，如果初始值是一个全局变量地址、或者外部定义函数的地址，链接时就会被修改</li>
</ul>
</li>
<li>.debug：一个调试符号表</li>
<li>.line：原始C程序中的行号和.text节中，机器指令之间的映射</li>
<li>.strtab：字符串表（就是以null结尾的字符串的序列）</li>
</ul>
<h1 id="5-符号和符号表"><a href="#5-符号和符号表" class="headerlink" title="5.符号和符号表"></a>5.符号和符号表</h1><ul>
<li>每个可重定位目标模块m都有一个符号表，包含信息：<ul>
<li>m的定义</li>
<li>引用的符号的信息</li>
</ul>
</li>
<li>连接器的三种符号<ul>
<li>在自己m义的、被其他m引用的全局符号【非静态的C函数、全局变量】</li>
<li>其他m定义的、被自己m引用的全局符号【相对于自己m，称为外部符号】</li>
<li>只被自己m定义，自己m引用的局部符号【static属性的C函数和全局变量，m内都可见，m外不可被引用】</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>综上小结：<ul>
<li>链接器对栈里的符号不感兴趣</li>
<li>符号表是由汇编器构造的</li>
</ul>
</li>
<li>上图的.symtab节中包含ELF符号表，这张符号表包含一个条目，包含了符号名、符号地址、位置偏移、type（要目数据、要么函数）、本地还是全局等信息。</li>
<li>可执行文件没有、只有<code>RTF</code>才有的符号：<ul>
<li>ABS：不该被重定位的符号</li>
<li>UNDEF：在自己m内引用，在其他m中定义的符号</li>
<li>COMMON：还没分配位置、没有初始化的数据目标？？？ 【这个不是很理解，看到实例代码里函数定义为COMMON了】</li>
</ul>
</li>
</ul>
<h1 id="6-符号解析"><a href="#6-符号解析" class="headerlink" title="6.符号解析"></a>6.符号解析</h1><h2 id="Q-链接器如何解析符号？"><a href="#Q-链接器如何解析符号？" class="headerlink" title="Q:链接器如何解析符号？"></a>Q:链接器如何解析符号？</h2><ol>
<li><p>链接器如何解析符号引用？</p>
<ul>
<li>编译器遇到不在当前m中定义的符号（变量、函数名），会假设符号是在其他m中定义的，然后交给链接器处理。连接器也找不到就抛出错误信息，终止链接。</li>
</ul>
</li>
<li><p>链接器如何解析多重定义的全局符号？</p>
<ul>
<li>规则1：不允许有多个同名的强符号</li>
<li>规则2：存在一个强符号和多个同名弱符号，那么选择强符号</li>
<li>规则3：存在多个同名弱符号，那么任意选择一个</li>
<li>ps：<ul>
<li>强符号：函数 和 已经初始化的全局变量</li>
<li>弱符号：未初始化的全局变量</li>
</ul>
</li>
</ul>
</li>
<li><p>链接器如何与静态库链接？</p>
<ul>
<li>静态库：相关的模块打包成单独的文件，可以作为连接器的输入</li>
</ul>
</li>
</ol>
<h5 id="首先理解静态库存在的必要性："><a href="#首先理解静态库存在的必要性：" class="headerlink" title="首先理解静态库存在的必要性："></a>首先理解静态库存在的必要性：</h5><p>场景：编译器开发人员如何向用户提供系统的数学函数库</p>
<ul>
<li><p>方案一：让编译器辨认对标准函数的辨认，直接生成相应的代码</p>
<ul>
<li>缺陷：<ul>
<li>增加编译器的复杂性，每次增、删、改函数，编译器都需要新的版本来支持</li>
</ul>
</li>
<li>好处：<ul>
<li>对使用的人友好（标准函数库总是可用的嘛，当然好）</li>
</ul>
</li>
</ul>
</li>
<li><p>方案二：把所有标准C函数放在一个单独的RTM（例如libc.o）</p>
<ul>
<li>缺陷：<ul>
<li>极度浪费内存空间，就算只使用一个函数，都整个RTM都被copu进内存</li>
<li>一个小的改变，都要重新编译整个RTM，过程很耗时，让开发和维护困难</li>
</ul>
</li>
<li>好处：<ul>
<li>对使用者依旧保持适度的友好</li>
</ul>
</li>
</ul>
</li>
<li><p>方案三：为每个标准函数，创建一个 独立的可重定位文件，把它们放在大家都知道的目录</p>
<ul>
<li>只能解决部分问题</li>
<li>缺陷：过程耗时、易出错</li>
</ul>
</li>
<li><p>方案四【静态库】：<code>相关的函数</code>被编译成<code>独立的目标模块</code>，再封装成<code>单独的静态库文件</code>，链接时，只复制被引用的目标模块</p>
<ul>
<li>好处：<ul>
<li>减少文件在磁盘和内存的大小</li>
<li>使用者只要包含库文件的名字【省去了手动编译它们的环节】</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>  示例：对向量的两个函数操作，记录函数被调用次数：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addvec.c 向量加法</span></span><br><span class="line"><span class="keyword">int</span> g_addcnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addvec</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y, <span class="keyword">int</span> *z, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_addcnt ++;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    z[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// multvec.c 向量乘法</span></span><br><span class="line"><span class="keyword">int</span> g_multcnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multvec</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y, <span class="keyword">int</span> *z, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_multcnt ++;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    z[i] = x[i] * y[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  使用AR工具创建静态库（库名字叫 libvector.a ）：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc addvec.c multvec.c</span><br><span class="line">$ ar rcs libvector.a addvec.o multvec.o</span><br></pre></td></tr></table></figure>

<p>  <code>vector.h</code>这个头文件定义了<code>libvector.a</code>的函数原型</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c 使用到了加法，没有使用乘法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector.h"</span> <span class="comment">// 这个头文件定义了libvector.a的函数原型</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    addvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"z = [%d, %d]\n"</span>,z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>  然后，编译和链接main.o和libvector.a</p>
  <figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c main2.c</span><br><span class="line">$ gcc -static -o prog2c ./libvector.a</span><br><span class="line">// -static参数的意思是，让链接器构建一个完全链接的可执行文件目标</span><br></pre></td></tr></table></figure>

<p>  链接器的行为见下图，发现了吗：</p>
<p>  从<code>libvector.a</code>里拷贝出来的只有<code>main.c</code>里用到的函数<code>addvec</code>，没有用到的乘法函数就不会被拷贝</p>
<p>  <img src="/2019/12/19/%E9%93%BE%E6%8E%A5/78.png" alt></p>
<ol start="4">
<li>链接器如何使用静态库解析引用？</li>
</ol>
<p>链接器维护了三个集合：</p>
<ul>
<li>集合E：这里的所有文件被结合成可执行文件</li>
<li>集合U：未解析的符号（即引用了但是未定义的符号）</li>
<li>集合D：在前面输入文件时时已经定了的符号</li>
</ul>
<p>方案已经给出，具体操作自行脑补</p>
<p>PS：初始时，所有集合为空</p>
<h1 id="7-重定位"><a href="#7-重定位" class="headerlink" title="7.重定位"></a>7.重定位</h1><p>链接器完成了解析（符号引用和定义关联），链接器就明确知道了输入模块中，代码节和数据节的大小。</p>
<p>重定位会合并数据模块，并为每个符号分配运行时地址。分两个步骤：</p>
<h5 id="步骤1：重定位「节」和「符号定义」"><a href="#步骤1：重定位「节」和「符号定义」" class="headerlink" title="步骤1：重定位「节」和「符号定义」"></a>步骤1：重定位「节」和「符号定义」</h5><p>所有相同类型的节合并成一个同类型的新的聚合节。例如，所有输入模块的.data节被合并成一个节，成为输出的RTF的.data节</p>
<p>然后，连接器把运行时内存地址赋值给：【此处不明白关输入模块神马事？？】</p>
<ul>
<li><p>输入模块定义的每个节</p>
</li>
<li><p>输入模块定义的每个符号</p>
</li>
<li><p>新的聚合节</p>
</li>
</ul>
<p>此时，程序的每条指令和全局变量都有唯一的运行时内存地址！！！！！！太激动了有木有==|</p>
<h5 id="步骤2：重定位节中的符号引用"><a href="#步骤2：重定位节中的符号引用" class="headerlink" title="步骤2：重定位节中的符号引用"></a>步骤2：重定位节中的符号引用</h5><p>修改代码节和数据节中，对每个符号的引用，使得它们指向正确的运行时地址。</p>
<p>这个过程依赖于RTM中的<code>重定位条目</code>的数据结构</p>
<h5 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h5><p>汇编器遇到对最终未知未知的引用，就会生成一个重定位条目，告诉链接器在合并RTF的时候，如何修改这个引用。</p>
<p>代码的重定位条目放在<code>.ref.text</code>。</p>
<p>已经初始化数据的重定位条目放在<code>.ref.data</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// relocatin entry</span></span><br><span class="line">typdef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> offset;   <span class="comment">/* Offset of the reference to relocate */</span></span><br><span class="line">  <span class="keyword">long</span> type: <span class="number">32</span>, <span class="comment">/* Relocation type */</span></span><br><span class="line">    symbol:<span class="number">32</span>;     <span class="comment">/* Symbol table index */</span></span><br><span class="line">  <span class="keyword">long</span> addend;     <span class="comment">/* Constant part of relocation expressioin */</span></span><br><span class="line">&#125;Elf64_Rela;</span><br></pre></td></tr></table></figure>



<p>重定位符号引用类型，ELF定义32种，最基本的两种：</p>
<ol>
<li>重定位PC相对引用</li>
<li>重定位绝对引用</li>
</ol>
<h1 id="8-可执行目标文件"><a href="#8-可执行目标文件" class="headerlink" title="8.可执行目标文件"></a>8.可执行目标文件</h1><p><img src="/2019/12/19/%E9%93%BE%E6%8E%A5/713.png" alt="典型的ELF可执行目标文件"></p>
<p>开头的C程序是一组ASCII文本文件，如今已转化为一个二进制文件，它包含了从加载程序到内存，并运行它的所有信息。</p>
<h1 id="9-加载可执行目标文件"><a href="#9-加载可执行目标文件" class="headerlink" title="9.加载可执行目标文件"></a>9.加载可执行目标文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./prog</span><br></pre></td></tr></table></figure>



<p><img src="/2019/12/19/%E9%93%BE%E6%8E%A5/715.png" alt></p>
<ul>
<li><p>把程序复制到内存并运行的过程叫加载(<code>load</code>)，由加载器(<code>loader</code>)完成</p>
</li>
<li><p><code>Linux x86-64</code>系统中，代码总是从<code>0x400000开始</code>，接着是数据段</p>
</li>
<li><p><code>malloc</code>库往上增长</p>
</li>
<li><p>用户栈最大从<code>2^48 - 1</code>开始，向小内存地址方向增长</p>
</li>
<li><p>从<code>2^48</code>开始，是为内核(<code>kernel</code>，OS驻留的地方)的代码和数据保留的</p>
<h5 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h5></li>
<li><p>加载器运行时创建的内存镜像如上图：</p>
<ol>
<li><p>由程序头部表引导loader把可执行文件的片（chunk）copy到代码段和数据段</p>
</li>
<li><p>加载器跳到程序入口点 <code>_start</code> 函数的地址</p>
</li>
</ol>
<ul>
<li><code>_start</code>存在于系统目标文件<code>ctrl.o</code>中，对所有的<code>C程序</code>都一样【统一了用户层APP入口？？？】</li>
</ul>
<p><code>3. _start</code>启动<code>__libc_start_main</code>函数</p>
<ul>
<li>这个函数定义在<code>libc.o</code>，负责初始化执行环境</li>
</ul>
<p><code>4. __libc_start_main</code>调用用户层的<code>main</code>函数</p>
<ul>
<li><code>__libc_start_main</code>处理<code>main</code>函数的返回值</li>
<li>在需要的时候把控制返回给内核</li>
</ul>
</li>
</ul>
<h1 id="10-动态链接共享库"><a href="#10-动态链接共享库" class="headerlink" title="10.动态链接共享库"></a>10.动态链接共享库</h1><p>共享库（share library）致力于解决静态库缺陷，是一个现代创新产物，是一个目标模块在运行或者加载时，可以加载到任意内存地址，并和内存中的程序链接。</p>
<p>这个过程叫做动态链接dynamic linking，由动态连接器dynamic linker完成。</p>
<blockquote>
<p>静态库缺陷：维护和更新不友好，需要用户程序与更新的库显示链接。此外，每个进程都会拷贝一份相同的函数，极大的浪费稀缺内存资源！！</p>
</blockquote>
<p>共享库又叫做共享目标，Linux系统中常用.so后缀表示，Windows用DLL（动态链接库）。</p>
<p>动态链接器也是一个共享目标，ld-lunux.so</p>
<p>拿上一段代码制作动态库，并加载的流程示例：</p>
<p><img src="/2019/12/19/%E9%93%BE%E6%8E%A5/716.png" alt></p>
<p>文件<code>prog2l</code>包含一个<code>.interp</code>节，里面包含动态链接器的路径名。</p>
<p>加载器会加载动态链接器，然后执行：</p>
<ul>
<li>重定位<code>libc.so</code>的文本和数据到某个内存段</li>
<li>重定位<code>libvector.so</code>的文本和数据到另一个内存段</li>
<li>重定位<code>prog2l</code>中所有对<code>libc.so</code>和<code>libvector.so</code>定义的符号的引用</li>
</ul>
<p>横向对比一下：</p>
<p><img src="/2019/12/19/%E9%93%BE%E6%8E%A5/7161.png" alt></p>
<h1 id="11-从应用程序中加载和链接共享库"><a href="#11-从应用程序中加载和链接共享库" class="headerlink" title="11.从应用程序中加载和链接共享库"></a>11.从应用程序中加载和链接共享库</h1><p>上一节讨论的是<code>application</code>被加载后执行前，加载和链接共享库的情景。</p>
<p>本节讨论<code>application</code>在运行时，加载和链接共享库的情景。</p>
<p>Linux系统为动态链接器提供一个简单的接口，让app在运行时加载和链接共享库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* filename:</span></span><br><span class="line"><span class="comment">*        链接共享库名</span></span><br><span class="line"><span class="comment">* flag:</span></span><br><span class="line"><span class="comment">*     RTLD_NOW：立即解析对外部符号的引用</span></span><br><span class="line"><span class="comment">*     RTLD_LAZY：延迟符号解析，直到来自库中的代码被执行</span></span><br><span class="line"><span class="comment">*    return：</span></span><br><span class="line"><span class="comment">*     成功时返回指向句柄的指针，错误时返回NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* handle:</span></span><br><span class="line"><span class="comment">*        指向共享库的句柄</span></span><br><span class="line"><span class="comment">* symbol:</span></span><br><span class="line"><span class="comment">*     符号名</span></span><br><span class="line"><span class="comment">*    return：</span></span><br><span class="line"><span class="comment">*     符号存在就返回符号地址，否则返回NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">char</span> *symbol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果没有其他共享库使用这个库，该函数会卸载该共享库【「卸载」的意思是，从内存删掉，磁盘保留吧？】</span></span><br><span class="line"><span class="comment">*    return：</span></span><br><span class="line"><span class="comment">*     成功为0，错误为-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlclose</span><span class="params">(<span class="keyword">void</span> *handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前如果前面三个函数之一调用失败，返回失败信息，否则返回NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>



<h1 id="12-位置无关代码"><a href="#12-位置无关代码" class="headerlink" title="12.位置无关代码"></a>12.位置无关代码</h1><p>可以加载、而无需重定位的代码，叫做位置无关代码（Positon-Independent Code，PIC）。</p>
<p>使用PIC方式编译共享模块的代码段，让它们被加载到内存的任何位置、而无需修改链接器。</p>
<p>原理是使用一张全局偏移量表（Global Offset Table，GOT）记录引用的目标偏移，使用时获得绝对地址。</p>
<h1 id="13-库打桩机制"><a href="#13-库打桩机制" class="headerlink" title="13.库打桩机制"></a>13.库打桩机制</h1><p>库打桩(library interposition)，允许你截获对共享库的调用，并执行你自己的代码。</p>
<p>能干嘛呢？</p>
<p>可以追踪某个特殊函数的调用此时，验证输入输出值，或者替换一个完全不相关的实现。</p>
<p>跟iOS里的hook很像，没错就是它老表。</p>
<h4 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h4><p>对于目标函数func_t，创建一个包装函数func_p，原型和func_t完全一样。利用打桩机制，欺骗系统调用func_p而不是func_t。然后在func_p里执行func_t，把func_t的返回值传递给调用者。</p>
<h4 id="打桩时机"><a href="#打桩时机" class="headerlink" title="打桩时机"></a>打桩时机</h4><ul>
<li>编译时</li>
<li>链接时</li>
<li>程序被加载和执行的运行时</li>
</ul>
<p>ps：对应的操作示例看书吧~</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>链接可以在编译时通过静态编译器完成，也可以通过动态链接器在加载和运行时完成。</p>
<hr>
<p>作为输出的二进制文件，目标文件有三个形式：</p>
<ul>
<li>可重定位的：由静态链接器合成一个可执行的目标文件，能加载到内存中执行</li>
<li>可执行的：</li>
<li>共享的：<ul>
<li>运行时由动态链接器链接和加载</li>
<li>程序在加载或者执行时</li>
<li>程序调用dlopen库的函数</li>
</ul>
</li>
</ul>
<hr>
<p>链接器的两个重要任务是符号解析和重定位，解析把全局符号绑定到一个唯一的定义，重定位确定每个符号的内存地址，并修改目标引用</p>
<hr>
<p>多个目标文件可以被链接到一个单独的静态库中。</p>
<p>加载器把可执行文件的内容映射到内存中，并运行这个程序。</p>
<p>如果链接器生成的可执行目标文件，内含有定义在共享库数据的未解析引用。加载的时候，加载器先把可执行文件映射到内存，然后调用动态链接器，去加载共享库和引用，完成链接任务。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" rel="tag"># 操作系统原理</a>
          
            <a href="/tags/%E7%BC%96%E8%AF%91/" rel="tag"># 编译</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/15/block%E6%9C%AC%E8%B4%A8%E6%8E%A2%E7%A9%B64-weak%E5%92%8C-block/" rel="next" title="block本质探究4-weak和-block">
                <i class="fa fa-chevron-left"></i> block本质探究4-weak和-block
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">YoU1024</p>
              <p class="site-description motion-element" itemprop="description">命运对勇士说/暴风雨要来了/勇士低语/我就是暴风雨</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#链接"><span class="nav-number">1.</span> <span class="nav-text">链接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-编译器驱动程序"><span class="nav-number">2.</span> <span class="nav-text">1.编译器驱动程序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-静态链接"><span class="nav-number">3.</span> <span class="nav-text">2.静态链接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-目标文件"><span class="nav-number">4.</span> <span class="nav-text">3.目标文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-RTF"><span class="nav-number">5.</span> <span class="nav-text">4.RTF</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-符号和符号表"><span class="nav-number">6.</span> <span class="nav-text">5.符号和符号表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-符号解析"><span class="nav-number">7.</span> <span class="nav-text">6.符号解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q-链接器如何解析符号？"><span class="nav-number">7.1.</span> <span class="nav-text">Q:链接器如何解析符号？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#首先理解静态库存在的必要性："><span class="nav-number">7.1.0.0.1.</span> <span class="nav-text">首先理解静态库存在的必要性：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-重定位"><span class="nav-number">8.</span> <span class="nav-text">7.重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#步骤1：重定位「节」和「符号定义」"><span class="nav-number">8.0.0.0.1.</span> <span class="nav-text">步骤1：重定位「节」和「符号定义」</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#步骤2：重定位节中的符号引用"><span class="nav-number">8.0.0.0.2.</span> <span class="nav-text">步骤2：重定位节中的符号引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重定位条目"><span class="nav-number">8.0.0.0.3.</span> <span class="nav-text">重定位条目</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-可执行目标文件"><span class="nav-number">9.</span> <span class="nav-text">8.可执行目标文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-加载可执行目标文件"><span class="nav-number">10.</span> <span class="nav-text">9.加载可执行目标文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#流程："><span class="nav-number">10.0.0.0.1.</span> <span class="nav-text">流程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-动态链接共享库"><span class="nav-number">11.</span> <span class="nav-text">10.动态链接共享库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-从应用程序中加载和链接共享库"><span class="nav-number">12.</span> <span class="nav-text">11.从应用程序中加载和链接共享库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-位置无关代码"><span class="nav-number">13.</span> <span class="nav-text">12.位置无关代码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-库打桩机制"><span class="nav-number">14.</span> <span class="nav-text">13.库打桩机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本思想："><span class="nav-number">14.0.0.1.</span> <span class="nav-text">基本思想：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打桩时机"><span class="nav-number">14.0.0.2.</span> <span class="nav-text">打桩时机</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">15.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YoU1024</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
